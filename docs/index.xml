<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>金成的博客</title>
    <link>https://jinchengjoker.github.io/</link>
    <description>Recent content on 金成的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <lastBuildDate>Sun, 06 Mar 2022 14:39:28 +0800</lastBuildDate><atom:link href="https://jinchengjoker.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Vue 数据响应式原理</title>
      <link>https://jinchengjoker.github.io/posts/vue/vue_data_reactivity/</link>
      <pubDate>Sun, 06 Mar 2022 14:39:28 +0800</pubDate>
      
      <guid>https://jinchengjoker.github.io/posts/vue/vue_data_reactivity/</guid>
      <description>断断续续已经用了很长时间的vue了，从之前的vue2到现在的vue3。说起它的数据响应式原理，一直都是比较模糊的，只是大概知道是通过Object.defineProperty()和代理来实现的，具体也没有去深入的了解。
最近看了一些文章和视频，所以在这里进行一些总结。
先了解一下 ES6 的 getter/setter 一个简单的例子了解getter/setter的基本用法：
const obj = { lastName: &amp;#34;高&amp;#34;, firstName: &amp;#34;圆圆&amp;#34;, get name() { return this.lastName + this.firstName }, set name(value){ this.lastName = value[0] this.firstName = value.substring(1) }, } console.log(obj.name) // 高圆圆  obj.name = &amp;#39;刘诗诗&amp;#39; console.log(`姓：${obj.lastName}`) // 姓：刘 console.log(`名：${obj.firstName}`) // 名：诗诗 需求一 上面的例子在声明obj的时候就已经定义了name的getter/setter，那如何在一个已有的对象上添加一个新的getter/setter？
再了解一下 ES6 的 Object.defineProperty 用ES6的新语法Object.defineProperty可以实现上述需求。
例如给obj对象添加一个age的getter/setter：
let _age = 0 Object.defineProperty(obj, &amp;#39;age&amp;#39;, { get() { return _age }, set(value) { _age = value } }) 这里需要一个_age变量作为临时存储，为了方便可以把这个临时的_age放到obj里：</description>
    </item>
    
    <item>
      <title>到底什么是前端架构？</title>
      <link>https://jinchengjoker.github.io/posts/misc/fe_arch/</link>
      <pubDate>Wed, 02 Mar 2022 20:30:50 +0800</pubDate>
      
      <guid>https://jinchengjoker.github.io/posts/misc/fe_arch/</guid>
      <description>文件夹划分师 </description>
    </item>
    
    <item>
      <title>Vue 之 MVVM</title>
      <link>https://jinchengjoker.github.io/posts/vue/vue_mvvm/</link>
      <pubDate>Tue, 01 Mar 2022 16:15:19 +0800</pubDate>
      
      <guid>https://jinchengjoker.github.io/posts/vue/vue_mvvm/</guid>
      <description>Vue 是 MVVM？ v1.0 版本 在vue v1.0版本的官网上有这么一张图：
可以看到在v1.0版本，当时vue把自己定义为一个MVVM模型的框架：
 Vue.js 拥抱数据驱动的视图概念。通俗地讲，它意味着我们在普通 HTML 模板中使用特殊的语法将 DOM “绑定”到底层数据。一旦创建了绑定，DOM 将与数据保持同步。每当修改了数据，DOM 便相应地更新。这样我们应用中的逻辑就几乎都是直接修改数据了，不必与 DOM 更新搅在一起。
 v2.x v3.x 版本 但是在后来的版本，vue的官网上就移除了这张图的介绍，取而代之的是下面这句话：
 虽然没有完全遵循 MVVM 模型，但是 Vue 的设计也受到了它的启发。
 在v2.x、v3.x版本，vue更像是一个MV*模型，因为它确实有些地方没有遵循MVVM模型。其实不必纠结这个*具体是指什么。
先顺便了解一下 MVC 引用阮一峰老师的文章，在前端层面可以很容易的理解什么是MCV：
  模型（Model）：数据保存 视图（View）：用户界面 控制器（Controller）：业务逻辑     View 传送指令到 Controller Controller 完成业务逻辑后，要求 Model 改变状态 Model 将新的数据发送到 View，渲染出视图（用户得到反馈）   Vue 是 MVVM MVVM是Model-View-ViewModel的缩写。阮一峰老师也介绍了MVVM，但是实在是过于概括。这里推荐廖雪峰老师的文章：
 MVVM 最早由微软提出来，它借鉴了桌面应用程序的 MVC 思想，在前端页面中，把 Model 用纯 JavaScript 对象表示，View 负责显示，两者做到了最大限度的分离。</description>
    </item>
    
    <item>
      <title>Vue 运行时&#43;编译器 vs. 仅运行时</title>
      <link>https://jinchengjoker.github.io/posts/vue/vue_runtime_runtime-only/</link>
      <pubDate>Tue, 22 Feb 2022 14:50:43 +0800</pubDate>
      
      <guid>https://jinchengjoker.github.io/posts/vue/vue_runtime_runtime-only/</guid>
      <description>在vue npm包的 dist/ 目录有很多不同的Vue.js构建版本。
 vue.global.js - 包含编译器和运行时的完整版（约 520KB） vue.global.prod.js - 包含编译器和运行时的压缩后完整版（约 105KB） vue.runtime.global.js - 只包含运行时（约 356KB） vue.runtime.global.prod.js - 只包含运行时的压缩版（约 68KB）  如果要在客户端上编译模板（即：将字符串传递给template选项，或者使用元素的DOM内HTML作为模板挂载到元素），则需要编译器，因此需要完整的构建版本：
&amp;lt;!-- index.html --&amp;gt; &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;h1&amp;gt;{{hi}}&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; // main.js // 以 vue3 写法为例  // 需要编译器 // 会直接替换 app 元素的内容 Vue.createApp({ template: &amp;#39;&amp;lt;div&amp;gt;{{ hi }}&amp;lt;/div&amp;gt;&amp;#39;, data() { return { hi: &amp;#34;hi&amp;#34; }; } }).mount(&amp;#39;#app&amp;#39;) // 需要编译器 // 相当于使用 app 元素的 DOM 内 HTML 作为模板 Vue.createApp({ data() { return { hi: &amp;#34;hi&amp;#34; }; } }).</description>
    </item>
    
    <item>
      <title>开博大吉</title>
      <link>https://jinchengjoker.github.io/posts/%E5%BC%80%E5%8D%9A%E5%A4%A7%E5%90%89/</link>
      <pubDate>Fri, 18 Feb 2022 18:21:16 +0800</pubDate>
      
      <guid>https://jinchengjoker.github.io/posts/%E5%BC%80%E5%8D%9A%E5%A4%A7%E5%90%89/</guid>
      <description>你他娘还真是个人才！ </description>
    </item>
    
  </channel>
</rss>
