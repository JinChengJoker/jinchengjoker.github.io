<!DOCTYPE html>











<html lang="zh-Hans">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

  
  <title>JS 中的原型和原型链 - 金成的博客</title>

  
  
  <meta name="description" content="公用属性 用全局函数包装下面几个对象：
var n = new Number(1) var s = new String(&#39;hello&#39;) var b = new Boolean(true) var o = new Object() 可以发现，他们都可以调用例如 toString() 和 valueOf() 等一些方法。
那如果每一个对象都自己去存有这些属性，一个明显的问题就是会造成资源的浪费。
JS 的解决办法就是，把这些函数统一放在一个对象里（暂且叫做公用属性组成的对象）。当声明一个新的对象时，就给这个新的对象添加一个隐藏的属性 __proto__，在这个属性中去存公用属性对象的 Heap 地址，这样就完成了对公用属性的引用。
Object 对象的公用属性 举个例子：
var o1 = {} o1.name = &#39;JinCheng&#39; o1.age = 20 console.log(o1) 就会发现额外隐藏的 __proto__ 属性。
当调用 o1.toString() 时：
 首先会看 o1 是不是对象，如果不是，就临时包装成对象。 再看 o1 自身有没有 toString 这个属性可供调用。 如果没有这个属性，就会自动去调用 __proto__ 对象里的属性方法。  简单的验证：
// 再声明一个对象 o2 var o2 = { name: &#39;JinCheng&#39;, age: 20 } o1 === o2 // false 因为 Heap 地址不同 o1." />
  <meta name="author" content="" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="https://jinchengjoker.github.io/app.min.css" />

  
  <link rel="preload stylesheet" as="style" href="https://jinchengjoker.github.io/an-old-hope.min.css" />
  <script
    defer
    src="https://jinchengjoker.github.io/highlight.min.js"
    onload="hljs.initHighlightingOnLoad();"
  ></script>
  

  
  <link rel="preload" as="image" href="https://jinchengjoker.github.io/theme.png" />

  

  
  <link rel="icon" href="https://jinchengjoker.github.io/favicon.ico" />
  <link rel="apple-touch-icon" href="https://jinchengjoker.github.io/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.92.2" />

  
  

  
  
  
  
  
  
  
  
  
  <meta property="og:title" content="JS 中的原型和原型链" />
<meta property="og:description" content="公用属性 用全局函数包装下面几个对象：
var n = new Number(1) var s = new String(&#39;hello&#39;) var b = new Boolean(true) var o = new Object() 可以发现，他们都可以调用例如 toString() 和 valueOf() 等一些方法。
那如果每一个对象都自己去存有这些属性，一个明显的问题就是会造成资源的浪费。
JS 的解决办法就是，把这些函数统一放在一个对象里（暂且叫做公用属性组成的对象）。当声明一个新的对象时，就给这个新的对象添加一个隐藏的属性 __proto__，在这个属性中去存公用属性对象的 Heap 地址，这样就完成了对公用属性的引用。
Object 对象的公用属性 举个例子：
var o1 = {} o1.name = &#39;JinCheng&#39; o1.age = 20 console.log(o1) 就会发现额外隐藏的 __proto__ 属性。
当调用 o1.toString() 时：
 首先会看 o1 是不是对象，如果不是，就临时包装成对象。 再看 o1 自身有没有 toString 这个属性可供调用。 如果没有这个属性，就会自动去调用 __proto__ 对象里的属性方法。  简单的验证：
// 再声明一个对象 o2 var o2 = { name: &#39;JinCheng&#39;, age: 20 } o1 === o2 // false 因为 Heap 地址不同 o1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jinchengjoker.github.io/posts/js/prototype/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-04-20T09:00:22+08:00" />
<meta property="article:modified_time" content="2018-04-20T09:00:22+08:00" />


  
  <meta itemprop="name" content="JS 中的原型和原型链">
<meta itemprop="description" content="公用属性 用全局函数包装下面几个对象：
var n = new Number(1) var s = new String(&#39;hello&#39;) var b = new Boolean(true) var o = new Object() 可以发现，他们都可以调用例如 toString() 和 valueOf() 等一些方法。
那如果每一个对象都自己去存有这些属性，一个明显的问题就是会造成资源的浪费。
JS 的解决办法就是，把这些函数统一放在一个对象里（暂且叫做公用属性组成的对象）。当声明一个新的对象时，就给这个新的对象添加一个隐藏的属性 __proto__，在这个属性中去存公用属性对象的 Heap 地址，这样就完成了对公用属性的引用。
Object 对象的公用属性 举个例子：
var o1 = {} o1.name = &#39;JinCheng&#39; o1.age = 20 console.log(o1) 就会发现额外隐藏的 __proto__ 属性。
当调用 o1.toString() 时：
 首先会看 o1 是不是对象，如果不是，就临时包装成对象。 再看 o1 自身有没有 toString 这个属性可供调用。 如果没有这个属性，就会自动去调用 __proto__ 对象里的属性方法。  简单的验证：
// 再声明一个对象 o2 var o2 = { name: &#39;JinCheng&#39;, age: 20 } o1 === o2 // false 因为 Heap 地址不同 o1."><meta itemprop="datePublished" content="2018-04-20T09:00:22+08:00" />
<meta itemprop="dateModified" content="2018-04-20T09:00:22+08:00" />
<meta itemprop="wordCount" content="270">
<meta itemprop="keywords" content="" />
  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="JS 中的原型和原型链"/>
<meta name="twitter:description" content="公用属性 用全局函数包装下面几个对象：
var n = new Number(1) var s = new String(&#39;hello&#39;) var b = new Boolean(true) var o = new Object() 可以发现，他们都可以调用例如 toString() 和 valueOf() 等一些方法。
那如果每一个对象都自己去存有这些属性，一个明显的问题就是会造成资源的浪费。
JS 的解决办法就是，把这些函数统一放在一个对象里（暂且叫做公用属性组成的对象）。当声明一个新的对象时，就给这个新的对象添加一个隐藏的属性 __proto__，在这个属性中去存公用属性对象的 Heap 地址，这样就完成了对公用属性的引用。
Object 对象的公用属性 举个例子：
var o1 = {} o1.name = &#39;JinCheng&#39; o1.age = 20 console.log(o1) 就会发现额外隐藏的 __proto__ 属性。
当调用 o1.toString() 时：
 首先会看 o1 是不是对象，如果不是，就临时包装成对象。 再看 o1 自身有没有 toString 这个属性可供调用。 如果没有这个属性，就会自动去调用 __proto__ 对象里的属性方法。  简单的验证：
// 再声明一个对象 o2 var o2 = { name: &#39;JinCheng&#39;, age: 20 } o1 === o2 // false 因为 Heap 地址不同 o1."/>

  
  
</head>


  <body class="not-ready" data-menu="false">
    <header class="header">
  
  <p class="logo">
    <a class="site-name" href="https://jinchengjoker.github.io/">金成的博客</a><a class="btn-dark"></a>
  </p>
  

  <script>
    let bodyClx = document.body.classList;
    let btnDark = document.querySelector('.btn-dark');
    let sysDark = window.matchMedia('(prefers-color-scheme: dark)');
    let darkVal = localStorage.getItem('dark');

    let setDark = (isDark) => {
      bodyClx[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark ? 'yes' : 'no');
    };

    setDark(darkVal ? darkVal === 'yes' : sysDark.matches);
    requestAnimationFrame(() => bodyClx.remove('not-ready'));

    btnDark.addEventListener('click', () => setDark(!bodyClx.contains('dark')));
    sysDark.addEventListener('change', (event) => setDark(event.matches));
  </script>

  
  

  
</header>


    <main class="main">

<article class="post-single">
  <header class="post-title">
    <p>
      
      <time>Apr 20, 2018</time>
      
      
    </p>
    <h1>JS 中的原型和原型链</h1>
  </header>
  <section class="post-content"><h2 id="公用属性">公用属性</h2>
<p>用全局函数包装下面几个对象：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Number(<span style="color:#ae81ff">1</span>)
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String(<span style="color:#e6db74">&#39;hello&#39;</span>)
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Boolean(<span style="color:#66d9ef">true</span>)
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Object()
</code></pre></div><p>可以发现，他们都可以调用例如 <code>toString()</code> 和 <code>valueOf()</code> 等一些方法。</p>
<p>那如果每一个对象都自己去存有这些属性，一个明显的问题就是会造成资源的浪费。</p>
<p><strong>JS 的解决办法就是，把这些函数统一放在一个对象里（暂且叫做公用属性组成的对象）。当声明一个新的对象时，就给这个新的对象添加一个隐藏的属性 <code>__proto__</code>，在这个属性中去存公用属性对象的 Heap 地址，这样就完成了对公用属性的引用。</strong></p>
<h3 id="object-对象的公用属性">Object 对象的公用属性</h3>
<p>举个例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">o1</span> <span style="color:#f92672">=</span> {}
<span style="color:#a6e22e">o1</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;JinCheng&#39;</span>
<span style="color:#a6e22e">o1</span>.<span style="color:#a6e22e">age</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">o1</span>)
</code></pre></div><p><img src="./images/object__proto__.jpg" alt="object__proto__"></p>
<p>就会发现额外隐藏的 <code>__proto__</code> 属性。</p>
<p>当调用 <code>o1.toString()</code> 时：</p>
<ol>
<li>首先会看 <code>o1</code> 是不是对象，如果不是，就临时包装成对象。</li>
<li>再看 <code>o1</code> 自身有没有 <code>toString</code> 这个属性可供调用。</li>
<li>如果没有这个属性，就会自动去调用 <code>__proto__</code> 对象里的属性方法。</li>
</ol>
<p>简单的验证：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#75715e">// 再声明一个对象 o2
</span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">o2</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;JinCheng&#39;</span>,
  <span style="color:#a6e22e">age</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">20</span>
}
<span style="color:#a6e22e">o1</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">o2</span>  <span style="color:#75715e">// false 因为 Heap 地址不同
</span><span style="color:#75715e"></span><span style="color:#a6e22e">o1</span>.<span style="color:#a6e22e">toString</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">o2</span>.<span style="color:#a6e22e">toString</span>  <span style="color:#75715e">// true 可以发现他们调用的其实是同一个公用属性
</span></code></pre></div><h3 id="非-object-对象的公用属性">非 Object 对象的公用属性</h3>
<p>以 Number 对象为例（String 对象和 Boolean 对象同理）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Number(<span style="color:#ae81ff">1</span>)
</code></pre></div><p>我们知道除了上面所有对象的公用属性之外，Number 对象还有它自己的一些属性方法。</p>
<p>例如：<code>toFixed()</code> 和 <code>toExponential()</code> 等，这些是只有 Number 对象才公用的属性。</p>
<p>声明一个 Object 对象：<code>var o = new Object()</code> 它是不能调用这些属性方法的，因为它的 <code>__proto__</code> 属性直接引用了 Object 对象的公用属性。</p>
<p>所以 Number 对象的 <code>__proto__</code> 属性就不能直接引用 Object 对象的公用属性，否则它也就同样没有办法调用这些属性方法了。</p>
<p><strong>解决办法就是，Number 对象的 <code>__proto__</code> 属性要先引用 Number 的公用属性对象，又因为这个被引用的公用属性对象其实也是一个对象，所以在这个 Number 的公用属性对象里面还会再有一个 <code>__proto__</code> 属性去引用 Object 的公用属性。</strong></p>
<p><img src="./images/public_property.jpg" alt="public_property"></p>
<p>在控制台打印出 <code>n</code>，就可以看到两层 <code>__proto__</code> ：</p>
<p><img src="./images/number__proto__.jpg" alt="number__proto__"></p>
<p>注意：</p>
<ol>
<li>如果对象自身和它的公用属性对象，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”。</li>
<li>这些同名属性不是同一个方法，他们不相等，可能有不同的用法。例如：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#75715e">// Number 对象 toString 方法可以接受一个参数，表示输出的进制
</span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>
<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">toString</span>(<span style="color:#ae81ff">8</span>)  <span style="color:#75715e">// &#39;12&#39;
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// Object 对象 toString 方法不能接参数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> {}
<span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">toString</span>()  <span style="color:#75715e">// &#34;[object Object]&#34;
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 验证
</span><span style="color:#75715e"></span><span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">toString</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">toString</span>  <span style="color:#75715e">// false
</span></code></pre></div><h2 id="prototype原型对象">Prototype（原型对象）</h2>
<p>上面的那些公用属性对象其实就叫做 Prototype（原型对象）。</p>
<p>JavaScript 规定，所有对象都有自己的原型对象（prototype）。</p>
<p>他们各自存在相应对象的 <code>prototype</code> 属性中，JS 引擎在初始化全局对象时就会构建他们。</p>
<p><img src="./images/prototype.jpg" alt="prototype"></p>
<p>简单的验证：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> {}
<span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">__proto__</span> <span style="color:#f92672">===</span> Object.<span style="color:#a6e22e">prototype</span>  <span style="color:#75715e">// true
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Number(<span style="color:#ae81ff">1</span>)
<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">__proto__</span> <span style="color:#f92672">===</span> Number.<span style="color:#a6e22e">prototype</span>  <span style="color:#75715e">// true
</span><span style="color:#75715e"></span><span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">__proto__</span>.<span style="color:#a6e22e">__proto__</span> <span style="color:#f92672">===</span> Object.<span style="color:#a6e22e">prototype</span>  <span style="color:#75715e">// true
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String(<span style="color:#e6db74">&#39;hello&#39;</span>)
<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">__proto__</span> <span style="color:#f92672">===</span> String.<span style="color:#a6e22e">prototype</span>  <span style="color:#75715e">// true
</span><span style="color:#75715e"></span><span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">__proto__</span>.<span style="color:#a6e22e">__proto__</span> <span style="color:#f92672">===</span> Object.<span style="color:#a6e22e">prototype</span>  <span style="color:#75715e">// true
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Boolean(<span style="color:#66d9ef">true</span>)
<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">__proto__</span> <span style="color:#f92672">===</span> Boolean.<span style="color:#a6e22e">prototype</span>  <span style="color:#75715e">// true
</span><span style="color:#75715e"></span><span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">__proto__</span>.<span style="color:#a6e22e">__proto__</span> <span style="color:#f92672">===</span> Object.<span style="color:#a6e22e">prototype</span>  <span style="color:#75715e">// true
</span></code></pre></div><h2 id="原型链">原型链</h2>
<p><strong>上面图例中的，从蓝色的线到 String 的 <code>prototype</code>，再到 Object 的 <code>prototype</code>，就是一条原型链。</strong></p>
<p>如果一层层地上溯，所有对象的原型最终都可以上溯到 <code>Object.prototype</code>。也就是说，所有对象都继承了 <code>Object.prototype</code> 的属性。这就是所有对象都有 <code>toString</code> 和 <code>valueOf</code> 方法的原因。</p>
<p>那么，<code>Object.prototype</code> 对象有没有它的原型呢？回答是 <code>Object.prototype</code> 的原型是 <code>null</code>。<code>null</code> 没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是 <code>null</code>。</p>
</section>

  
  

  
  
  
  <nav class="post-nav">
    
    <a class="prev" href="https://jinchengjoker.github.io/posts/js/array_in_js/"><span>←</span><span>JS 中的数组</span></a>
     
    <a class="next" href="https://jinchengjoker.github.io/posts/js/object_in_js/"><span>JS 中的对象</span><span>→</span></a>
    
  </nav>
  

  
  
</article>

</main>

    <footer class="footer">
  <p>&copy; 2022 <a href="https://jinchengjoker.github.io/">金成的博客</a></p>
  <p>Powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo️️</a>️</p>
  <p>
    <a href="https://github.com/nanxiaobei/hugo-paper" rel="noopener" target="_blank">Paper 5.1</a>
  </p>
</footer>

  </body>
</html>
