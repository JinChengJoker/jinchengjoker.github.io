<!DOCTYPE html>











<html lang="zh-Hans">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

  
  <title>Vue3 响应性原理之 Proxy &amp; Reflect - 金成的博客</title>

  
  
  <meta name="description" content="之前已经实现了vue3响应性系统中如何记录代码，并在需要的时候可以再次执行它们：Vue3 响应性原理之 track &amp; trigger。
然而问题是现在只能手动的调用track和trigger，现在就来解决这个问题。
为什么 Vue3 要重写数据响应实现 在vue的早期版本，使用data选项是会存在一些响应性问题的（看这里）。
这主要是因为受限于当时ES6语法还并未在众多浏览器中普及，vue使用了兼容性更好的Object.definePropety和getter/setter来实现数据响应性。
进入vue3时代，随着ES6语法的普及，vue也使用Proxy和Reflect重新改写了数据响应的实现。
Proxy 的基本用法 Proxy顾名思义，它可以对一个对象进行代理，允许你拦截对该对象的任何操作。
const product = { price: 5, quantity: 2 } const proxiedProduct = new Proxy(product, { get(target, key) { // target === product  return target[key] }, set(target, key, value) { // target === product  target[key] = value } }) console.log(proxiedProduct.quantity) // 2  proxiedProduct.price = 10 console.log(product.price) // 10 这里get和set中的target参数就是被代理的对象product。
使用Proxy相比于Object.definePropety好的其中一点在于，不需要提前声明好所有的key，就可以拦截对目标对象的任何操作，这样就避免了vue之前版本中出现的问题。
Proxy 中 this 指向的问题 把上面的例子升级一下：" />
  <meta name="author" content="" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="https://jinchengjoker.github.io/app.min.css" />

  
  <link rel="preload stylesheet" as="style" href="https://jinchengjoker.github.io/an-old-hope.min.css" />
  <script
    defer
    src="https://jinchengjoker.github.io/highlight.min.js"
    onload="hljs.initHighlightingOnLoad();"
  ></script>
  

  
  <link rel="preload" as="image" href="https://jinchengjoker.github.io/theme.png" />

  

  
  <link rel="icon" href="https://jinchengjoker.github.io/favicon.ico" />
  <link rel="apple-touch-icon" href="https://jinchengjoker.github.io/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.92.2" />

  
  

  
  
  
  
  
  
  
  
  
  <meta property="og:title" content="Vue3 响应性原理之 Proxy &amp; Reflect" />
<meta property="og:description" content="之前已经实现了vue3响应性系统中如何记录代码，并在需要的时候可以再次执行它们：Vue3 响应性原理之 track &amp; trigger。
然而问题是现在只能手动的调用track和trigger，现在就来解决这个问题。
为什么 Vue3 要重写数据响应实现 在vue的早期版本，使用data选项是会存在一些响应性问题的（看这里）。
这主要是因为受限于当时ES6语法还并未在众多浏览器中普及，vue使用了兼容性更好的Object.definePropety和getter/setter来实现数据响应性。
进入vue3时代，随着ES6语法的普及，vue也使用Proxy和Reflect重新改写了数据响应的实现。
Proxy 的基本用法 Proxy顾名思义，它可以对一个对象进行代理，允许你拦截对该对象的任何操作。
const product = { price: 5, quantity: 2 } const proxiedProduct = new Proxy(product, { get(target, key) { // target === product  return target[key] }, set(target, key, value) { // target === product  target[key] = value } }) console.log(proxiedProduct.quantity) // 2  proxiedProduct.price = 10 console.log(product.price) // 10 这里get和set中的target参数就是被代理的对象product。
使用Proxy相比于Object.definePropety好的其中一点在于，不需要提前声明好所有的key，就可以拦截对目标对象的任何操作，这样就避免了vue之前版本中出现的问题。
Proxy 中 this 指向的问题 把上面的例子升级一下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jinchengjoker.github.io/posts/vue/vue3_reactivity_proxy_reflect/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-19T11:28:00+08:00" />
<meta property="article:modified_time" content="2022-04-19T11:28:00+08:00" />


  
  <meta itemprop="name" content="Vue3 响应性原理之 Proxy &amp; Reflect">
<meta itemprop="description" content="之前已经实现了vue3响应性系统中如何记录代码，并在需要的时候可以再次执行它们：Vue3 响应性原理之 track &amp; trigger。
然而问题是现在只能手动的调用track和trigger，现在就来解决这个问题。
为什么 Vue3 要重写数据响应实现 在vue的早期版本，使用data选项是会存在一些响应性问题的（看这里）。
这主要是因为受限于当时ES6语法还并未在众多浏览器中普及，vue使用了兼容性更好的Object.definePropety和getter/setter来实现数据响应性。
进入vue3时代，随着ES6语法的普及，vue也使用Proxy和Reflect重新改写了数据响应的实现。
Proxy 的基本用法 Proxy顾名思义，它可以对一个对象进行代理，允许你拦截对该对象的任何操作。
const product = { price: 5, quantity: 2 } const proxiedProduct = new Proxy(product, { get(target, key) { // target === product  return target[key] }, set(target, key, value) { // target === product  target[key] = value } }) console.log(proxiedProduct.quantity) // 2  proxiedProduct.price = 10 console.log(product.price) // 10 这里get和set中的target参数就是被代理的对象product。
使用Proxy相比于Object.definePropety好的其中一点在于，不需要提前声明好所有的key，就可以拦截对目标对象的任何操作，这样就避免了vue之前版本中出现的问题。
Proxy 中 this 指向的问题 把上面的例子升级一下："><meta itemprop="datePublished" content="2022-04-19T11:28:00+08:00" />
<meta itemprop="dateModified" content="2022-04-19T11:28:00+08:00" />
<meta itemprop="wordCount" content="616">
<meta itemprop="keywords" content="" />
  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Vue3 响应性原理之 Proxy &amp; Reflect"/>
<meta name="twitter:description" content="之前已经实现了vue3响应性系统中如何记录代码，并在需要的时候可以再次执行它们：Vue3 响应性原理之 track &amp; trigger。
然而问题是现在只能手动的调用track和trigger，现在就来解决这个问题。
为什么 Vue3 要重写数据响应实现 在vue的早期版本，使用data选项是会存在一些响应性问题的（看这里）。
这主要是因为受限于当时ES6语法还并未在众多浏览器中普及，vue使用了兼容性更好的Object.definePropety和getter/setter来实现数据响应性。
进入vue3时代，随着ES6语法的普及，vue也使用Proxy和Reflect重新改写了数据响应的实现。
Proxy 的基本用法 Proxy顾名思义，它可以对一个对象进行代理，允许你拦截对该对象的任何操作。
const product = { price: 5, quantity: 2 } const proxiedProduct = new Proxy(product, { get(target, key) { // target === product  return target[key] }, set(target, key, value) { // target === product  target[key] = value } }) console.log(proxiedProduct.quantity) // 2  proxiedProduct.price = 10 console.log(product.price) // 10 这里get和set中的target参数就是被代理的对象product。
使用Proxy相比于Object.definePropety好的其中一点在于，不需要提前声明好所有的key，就可以拦截对目标对象的任何操作，这样就避免了vue之前版本中出现的问题。
Proxy 中 this 指向的问题 把上面的例子升级一下："/>

  
  
</head>


  <body class="not-ready" data-menu="false">
    <header class="header">
  
  <p class="logo">
    <a class="site-name" href="https://jinchengjoker.github.io/">金成的博客</a><a class="btn-dark"></a>
  </p>
  

  <script>
    let bodyClx = document.body.classList;
    let btnDark = document.querySelector('.btn-dark');
    let sysDark = window.matchMedia('(prefers-color-scheme: dark)');
    let darkVal = localStorage.getItem('dark');

    let setDark = (isDark) => {
      bodyClx[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark ? 'yes' : 'no');
    };

    setDark(darkVal ? darkVal === 'yes' : sysDark.matches);
    requestAnimationFrame(() => bodyClx.remove('not-ready'));

    btnDark.addEventListener('click', () => setDark(!bodyClx.contains('dark')));
    sysDark.addEventListener('change', (event) => setDark(event.matches));
  </script>

  
  

  
</header>


    <main class="main">

<article class="post-single">
  <header class="post-title">
    <p>
      
      <time>Apr 19, 2022</time>
      
      
    </p>
    <h1>Vue3 响应性原理之 Proxy &amp; Reflect</h1>
  </header>
  <section class="post-content"><p>之前已经实现了<code>vue3</code>响应性系统中如何记录代码，并在需要的时候可以再次执行它们：<a href="https://jinchengjoker.github.io/posts/vue/vue3_reactivity_track_trigger/">Vue3 响应性原理之 track &amp; trigger</a>。</p>
<p>然而问题是现在只能手动的调用<code>track</code>和<code>trigger</code>，现在就来解决这个问题。</p>
<h2 id="为什么-vue3-要重写数据响应实现">为什么 Vue3 要重写数据响应实现</h2>
<p>在<code>vue</code>的早期版本，使用<code>data</code>选项是会存在一些响应性问题的（<a href="https://jinchengjoker.github.io/posts/vue/vue2_data_problem/">看这里</a>）。</p>
<p>这主要是因为受限于当时<code>ES6</code>语法还并未在众多浏览器中普及，<code>vue</code>使用了兼容性更好的<code>Object.definePropety</code>和<code>getter/setter</code>来实现数据响应性。</p>
<p>进入<code>vue3</code>时代，随着<code>ES6</code>语法的普及，<code>vue</code>也使用<code>Proxy</code>和<code>Reflect</code>重新改写了数据响应的实现。</p>
<h2 id="proxy-的基本用法">Proxy 的基本用法</h2>
<p><code>Proxy</code>顾名思义，它可以对一个对象进行代理，允许你拦截对该对象的任何操作。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">product</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">price</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">5</span>, <span style="color:#a6e22e">quantity</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span> }

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">proxiedProduct</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Proxy(<span style="color:#a6e22e">product</span>, {
  <span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>) {  <span style="color:#75715e">// target === product
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">target</span>[<span style="color:#a6e22e">key</span>]
  },
  <span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span>) {  <span style="color:#75715e">// target === product
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">target</span>[<span style="color:#a6e22e">key</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">value</span>
  }
})

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">proxiedProduct</span>.<span style="color:#a6e22e">quantity</span>)  <span style="color:#75715e">// 2
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">proxiedProduct</span>.<span style="color:#a6e22e">price</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">product</span>.<span style="color:#a6e22e">price</span>)  <span style="color:#75715e">// 10
</span></code></pre></div><p>这里<code>get</code>和<code>set</code>中的<code>target</code>参数就是被代理的对象<code>product</code>。</p>
<p>使用<code>Proxy</code>相比于<code>Object.definePropety</code>好的其中一点在于，不需要提前声明好所有的<code>key</code>，就可以拦截对目标对象的任何操作，这样就避免了<code>vue</code>之前版本中出现的问题。</p>
<h2 id="proxy-中-this-指向的问题">Proxy 中 this 指向的问题</h2>
<p>把上面的例子升级一下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">product</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">price</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">5</span>,
  <span style="color:#a6e22e">quantity</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span>,
  <span style="color:#a6e22e">get</span> <span style="color:#a6e22e">total</span>() {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">price</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">quantity</span>
  }
}

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">proxiedProduct</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Proxy(<span style="color:#a6e22e">product</span>, {
  <span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>) {  <span style="color:#75715e">// target === product
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">target</span>[<span style="color:#a6e22e">key</span>]
  },
  <span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span>) {  <span style="color:#75715e">// target === product
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">target</span>[<span style="color:#a6e22e">key</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">value</span>
  }
})

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">productA</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">price</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">10</span>,
  <span style="color:#a6e22e">quantity</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">4</span>,
  <span style="color:#a6e22e">__proto__</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">proxiedProduct</span>
}

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">productA</span>.<span style="color:#a6e22e">total</span>)  <span style="color:#75715e">// 10
</span></code></pre></div><p>实际上这里预期打印结果的应该是<code>productA.price * productA.quantity = 40</code>，但由于<code>get</code>和<code>set</code>中的<code>target</code>永远都是指向<code>product</code>，导致<code>total</code>中的<code>this</code>也总是都指向了<code>product</code>，所以结果变成了<code>product.price * product.quantity = 10</code>。</p>
<p>其实<code>get</code>和<code>set</code>中还提供了一个额外的参数<code>receiver</code>，它总是指向实际的调用者，在这个例子中指向的就是<code>productA</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">proxiedProduct</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Proxy(<span style="color:#a6e22e">product</span>, {
  <span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">receiver</span>) {  <span style="color:#75715e">// receiver === productA
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">target</span>[<span style="color:#a6e22e">key</span>]
  },
  <span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">receiver</span>) {  <span style="color:#75715e">// receiver === productA
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">target</span>[<span style="color:#a6e22e">key</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">value</span>
  }
})
</code></pre></div><p>那把这个<code>receiver</code>传递给<code>total</code>的<code>this</code>就可以了。</p>
<p>对于一般的函数，我们可以使用<code>call/bind/apply</code>来指定<code>this</code>绑定，但是这里的<code>target[key]</code>是一个<code>getter</code>函数，无法指定<code>this</code>。</p>
<p>为了更好的解决上述<code>this</code>指向的问题，需要用到<code>ES6</code>提供的<code>Reflect</code>语法。</p>
<h2 id="reflect-的基本用法">Reflect 的基本用法</h2>
<p><code>Reflect</code>对象上挂载了很多静态方法，所谓静态方法，就是和<code>Math.round()</code>这样。</p>
<p>其中比较常用的两个方法就是<code>get()</code>和<code>set()</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a6e22e">Reflect</span>.<span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">product</span>, <span style="color:#e6db74">&#39;quantity&#39;</span>)  <span style="color:#75715e">// 2
</span><span style="color:#75715e"></span><span style="color:#a6e22e">Reflect</span>.<span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">product</span>, <span style="color:#e6db74">&#39;price&#39;</span>, <span style="color:#ae81ff">10</span>)
</code></pre></div><p>它们几乎等同于：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a6e22e">product</span>[<span style="color:#e6db74">&#39;quantity&#39;</span>]  <span style="color:#75715e">// 2
</span><span style="color:#75715e"></span><span style="color:#a6e22e">product</span>[<span style="color:#e6db74">&#39;price&#39;</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>
</code></pre></div><p>所以上面的例子可以改写为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">proxiedProduct</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Proxy(<span style="color:#a6e22e">product</span>, {
  <span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">receiver</span>) {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Reflect</span>.<span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>)
  },
  <span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">receiver</span>) {
    <span style="color:#a6e22e">Reflect</span>.<span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span>)
  }
})
</code></pre></div><p>同时<code>Reflect.get</code>和<code>Reflect.set</code>还可以接收一个额外参数，用于可能存在的<code>setter</code>和<code>getter</code>中<code>this</code>的绑定。这样就能很好的解决上述例子中，打印结果不符合预期的问题：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">product</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">price</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">5</span>,
  <span style="color:#a6e22e">quantity</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span>,
  <span style="color:#a6e22e">get</span> <span style="color:#a6e22e">total</span>() {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">price</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">quantity</span>
  }
}

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">proxiedProduct</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Proxy(<span style="color:#a6e22e">product</span>, {
  <span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">receiver</span>) {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Reflect</span>.<span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">receiver</span>)
    <span style="color:#75715e">// or
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// return Reflect.get(...args)
</span><span style="color:#75715e"></span>  },
  <span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">receiver</span>) {
    <span style="color:#a6e22e">Reflect</span>.<span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">receiver</span>)
    <span style="color:#75715e">// or
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Reflect.set(..args)
</span><span style="color:#75715e"></span>  }
})

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">productA</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">price</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">10</span>,
  <span style="color:#a6e22e">quantity</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">4</span>,
  <span style="color:#a6e22e">__proto__</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">proxiedProduct</span>
}

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">productA</span>.<span style="color:#a6e22e">total</span>)  <span style="color:#75715e">// 40
</span></code></pre></div><h2 id="使用-reflect-的原因好处">使用 Reflect 的原因/好处</h2>
<p>除了上面说的使用<code>Reflect</code>可以很好的解决<code>this</code>的指向问题之外，还有另外两个好处：</p>
<ol>
<li><code>Reflect</code>提供的方法与<code>Proxy</code>提供的拦截器方法一一对应，只要是<code>Proxy</code>上的方法，就能在<code>Reflect</code>上找到对应的方法。这就让<code>Proxy</code>对象可以方便地调用对应的<code>Reflect</code>方法，完成默认行为，作为修改行为的基础，同时代码也更容易阅读和美观。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">proxiedObj</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Proxy(<span style="color:#a6e22e">obj</span>, {
  <span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>) {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;get&#39;</span>, <span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>)
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Reflect</span>.<span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>)
  },
  <span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span>) {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;set&#39;</span>, <span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span>)
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Reflect</span>.<span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span>)
  },
  <span style="color:#a6e22e">deleteProperty</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>) {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;delete&#39;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">key</span>)
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Reflect</span>.<span style="color:#a6e22e">deleteProperty</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>)
  },
  <span style="color:#a6e22e">has</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>) {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;has&#39;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">key</span>)
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Reflect</span>.<span style="color:#a6e22e">has</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>)
  }
})
</code></pre></div><ol start="2">
<li>使用<code>Reflect</code>有些返回值更加合理。比如<code>Reflect.set(target, key, value, receiver)</code>失败时会返回<code>false</code>，不会因为报错而中断正常的代码逻辑执行。</li>
</ol>
<h2 id="结合-track--trigger">结合 track &amp; trigger</h2>
<p>综上所述，可以封装出成一个<code>reactive</code>函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">reactive</span>(<span style="color:#a6e22e">target</span>) {
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">handler</span> <span style="color:#f92672">=</span> {
    <span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">receiver</span>) {
      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Reflect</span>.<span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">receiver</span>)
    },
    <span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">receiver</span>) {
      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Reflect</span>.<span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">receiver</span>)
    }
  }
  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Proxy(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">handler</span>)
}

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">product</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">reactive</span>({ <span style="color:#a6e22e">price</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">5</span>, <span style="color:#a6e22e">quantity</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span> })
<span style="color:#a6e22e">product</span>.<span style="color:#a6e22e">quantity</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">product</span>.<span style="color:#a6e22e">quantity</span>)  <span style="color:#75715e">// 4
</span></code></pre></div><p>显而易见，我们已经完全代理/监控了对<code>target</code>的读和写，只需要在<code>handler.get</code>和<code>handler.set</code>中分别调用<code>track</code>和<code>trigger</code>即可实现目标：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">reactive</span>(<span style="color:#a6e22e">target</span>) {
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">handler</span> <span style="color:#f92672">=</span> {
    <span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">receiver</span>) {
      <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Reflect</span>.<span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">receiver</span>)
      <span style="color:#75715e">// call track
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>
    },
    <span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">receiver</span>) {
      <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">oldValue</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">target</span>[<span style="color:#a6e22e">key</span>]
      <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Reflect</span>.<span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">receiver</span>)
      <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">result</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">oldValue</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">value</span>) {
        <span style="color:#75715e">// call trigger
</span><span style="color:#75715e"></span>      } 
      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>
    }
  }
  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Proxy(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">handler</span>)
}
</code></pre></div><h2 id="完整的代码">完整的代码</h2>
<p>以下即是<code>vue3</code>中<code>reactive</code>的实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">targetMap</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">WeakMap</span>()

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">track</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>) {
  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">depsMap</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">targetMap</span>.<span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">target</span>)
  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">depsMap</span>) {
    <span style="color:#a6e22e">targetMap</span>.<span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">target</span>, (<span style="color:#a6e22e">depsMap</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Map</span>()))
  }

  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">dep</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">depsMap</span>.<span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">key</span>)
  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">dep</span>) {
    <span style="color:#a6e22e">depsMap</span>.<span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">key</span>, (<span style="color:#a6e22e">dep</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Set</span>()))
  }

  <span style="color:#a6e22e">dep</span>.<span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">effect</span>)
}

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">trigger</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>) {
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">depsMap</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">targetMap</span>.<span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">target</span>)
  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">depsMap</span>) {
    <span style="color:#66d9ef">return</span>
  }

  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">dep</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">depsMap</span>.<span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">key</span>)
  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">dep</span>) {
    <span style="color:#a6e22e">dep</span>.<span style="color:#a6e22e">forEach</span>(<span style="color:#a6e22e">effect</span> =&gt; {
      <span style="color:#a6e22e">effect</span>()
    })
  }
}

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">reactive</span>(<span style="color:#a6e22e">target</span>) {
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">handler</span> <span style="color:#f92672">=</span> {
    <span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">receiver</span>) {
      <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Reflect</span>.<span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">receiver</span>)
      <span style="color:#a6e22e">track</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>)
      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>
    },
    <span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">receiver</span>) {
      <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">oldValue</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">target</span>[<span style="color:#a6e22e">key</span>]
      <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Reflect</span>.<span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">receiver</span>)
      <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">result</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">oldValue</span> <span style="color:#f92672">!==</span> <span style="color:#a6e22e">value</span>) {
        <span style="color:#a6e22e">trigger</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>)
      }
      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>
    }
  }
  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Proxy(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">handler</span>)
}

<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">product</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">reactive</span>({ <span style="color:#a6e22e">price</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">5</span>, <span style="color:#a6e22e">quantity</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span> })
<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">total</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">effect</span> <span style="color:#f92672">=</span> () =&gt; {
  <span style="color:#a6e22e">total</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">product</span>.<span style="color:#a6e22e">price</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">product</span>.<span style="color:#a6e22e">quantity</span>
}
<span style="color:#a6e22e">effect</span>()

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">total</span>)  <span style="color:#75715e">// 10
</span><span style="color:#75715e"></span><span style="color:#a6e22e">product</span>.<span style="color:#a6e22e">quantity</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">total</span>)  <span style="color:#75715e">// 15
</span></code></pre></div><p><em>以上例子和思路均来源于官方教程 <a href="https://www.vuemastery.com/courses/vue-3-reactivity/proxy-and-reflect">Vue Mastery</a></em>。</p>
</section>

  
  

  
  
  
  <nav class="post-nav">
     
    <a class="next" href="https://jinchengjoker.github.io/posts/vue/vue3_reactivity_track_trigger/"><span>Vue3 响应性原理之 track &amp; trigger</span><span>→</span></a>
    
  </nav>
  

  
  
</article>

</main>

    <footer class="footer">
  <p>&copy; 2022 <a href="https://jinchengjoker.github.io/">金成的博客</a></p>
  <p>Powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo️️</a>️</p>
  <p>
    <a href="https://github.com/nanxiaobei/hugo-paper" rel="noopener" target="_blank">Paper 5.1</a>
  </p>
</footer>

  </body>
</html>
