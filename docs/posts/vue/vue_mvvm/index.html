<!DOCTYPE html>











<html lang="zh-Hans">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

  
  <title>Vue 之 MVVM - 金成的博客</title>

  
  
  <meta name="description" content="Vue 是 MVVM？ v1.0 版本 在vue v1.0版本的官网上有这么一张图：
可以看到在v1.0版本，当时vue把自己定义为一个MVVM模型的框架：
 Vue.js 拥抱数据驱动的视图概念。通俗地讲，它意味着我们在普通 HTML 模板中使用特殊的语法将 DOM “绑定”到底层数据。一旦创建了绑定，DOM 将与数据保持同步。每当修改了数据，DOM 便相应地更新。这样我们应用中的逻辑就几乎都是直接修改数据了，不必与 DOM 更新搅在一起。
 v2.x v3.x 版本 但是在后来的版本，vue的官网上就移除了这张图的介绍，取而代之的是下面这句话：
 虽然没有完全遵循 MVVM 模型，但是 Vue 的设计也受到了它的启发。
 在v2.x、v3.x版本，vue更像是一个MV*模型，因为它确实有些地方没有遵循MVVM模型。其实不必纠结这个*具体是指什么。
先顺便了解一下 MVC 引用阮一峰老师的文章，在前端层面可以很容易的理解什么是MCV：
  模型（Model）：数据保存 视图（View）：用户界面 控制器（Controller）：业务逻辑     View 传送指令到 Controller Controller 完成业务逻辑后，要求 Model 改变状态 Model 将新的数据发送到 View，渲染出视图（用户得到反馈）   Vue 是 MVVM MVVM是Model-View-ViewModel的缩写。阮一峰老师也介绍了MVVM，但是实在是过于概括。这里推荐廖雪峰老师的文章：
 MVVM 最早由微软提出来，它借鉴了桌面应用程序的 MVC 思想，在前端页面中，把 Model 用纯 JavaScript 对象表示，View 负责显示，两者做到了最大限度的分离。" />
  <meta name="author" content="" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="https://jinchengjoker.github.io/app.min.css" />

  
  <link rel="preload stylesheet" as="style" href="https://jinchengjoker.github.io/an-old-hope.min.css" />
  <script
    defer
    src="https://jinchengjoker.github.io/highlight.min.js"
    onload="hljs.initHighlightingOnLoad();"
  ></script>
  

  
  <link rel="preload" as="image" href="https://jinchengjoker.github.io/theme.png" />

  

  
  <link rel="icon" href="https://jinchengjoker.github.io/favicon.ico" />
  <link rel="apple-touch-icon" href="https://jinchengjoker.github.io/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.92.2" />

  
  

  
  
  
  
  
  
  
  
  
  <meta property="og:title" content="Vue 之 MVVM" />
<meta property="og:description" content="Vue 是 MVVM？ v1.0 版本 在vue v1.0版本的官网上有这么一张图：
可以看到在v1.0版本，当时vue把自己定义为一个MVVM模型的框架：
 Vue.js 拥抱数据驱动的视图概念。通俗地讲，它意味着我们在普通 HTML 模板中使用特殊的语法将 DOM “绑定”到底层数据。一旦创建了绑定，DOM 将与数据保持同步。每当修改了数据，DOM 便相应地更新。这样我们应用中的逻辑就几乎都是直接修改数据了，不必与 DOM 更新搅在一起。
 v2.x v3.x 版本 但是在后来的版本，vue的官网上就移除了这张图的介绍，取而代之的是下面这句话：
 虽然没有完全遵循 MVVM 模型，但是 Vue 的设计也受到了它的启发。
 在v2.x、v3.x版本，vue更像是一个MV*模型，因为它确实有些地方没有遵循MVVM模型。其实不必纠结这个*具体是指什么。
先顺便了解一下 MVC 引用阮一峰老师的文章，在前端层面可以很容易的理解什么是MCV：
  模型（Model）：数据保存 视图（View）：用户界面 控制器（Controller）：业务逻辑     View 传送指令到 Controller Controller 完成业务逻辑后，要求 Model 改变状态 Model 将新的数据发送到 View，渲染出视图（用户得到反馈）   Vue 是 MVVM MVVM是Model-View-ViewModel的缩写。阮一峰老师也介绍了MVVM，但是实在是过于概括。这里推荐廖雪峰老师的文章：
 MVVM 最早由微软提出来，它借鉴了桌面应用程序的 MVC 思想，在前端页面中，把 Model 用纯 JavaScript 对象表示，View 负责显示，两者做到了最大限度的分离。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jinchengjoker.github.io/posts/vue/vue_mvvm/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-01T16:15:19+08:00" />
<meta property="article:modified_time" content="2022-03-01T16:15:19+08:00" />


  
  <meta itemprop="name" content="Vue 之 MVVM">
<meta itemprop="description" content="Vue 是 MVVM？ v1.0 版本 在vue v1.0版本的官网上有这么一张图：
可以看到在v1.0版本，当时vue把自己定义为一个MVVM模型的框架：
 Vue.js 拥抱数据驱动的视图概念。通俗地讲，它意味着我们在普通 HTML 模板中使用特殊的语法将 DOM “绑定”到底层数据。一旦创建了绑定，DOM 将与数据保持同步。每当修改了数据，DOM 便相应地更新。这样我们应用中的逻辑就几乎都是直接修改数据了，不必与 DOM 更新搅在一起。
 v2.x v3.x 版本 但是在后来的版本，vue的官网上就移除了这张图的介绍，取而代之的是下面这句话：
 虽然没有完全遵循 MVVM 模型，但是 Vue 的设计也受到了它的启发。
 在v2.x、v3.x版本，vue更像是一个MV*模型，因为它确实有些地方没有遵循MVVM模型。其实不必纠结这个*具体是指什么。
先顺便了解一下 MVC 引用阮一峰老师的文章，在前端层面可以很容易的理解什么是MCV：
  模型（Model）：数据保存 视图（View）：用户界面 控制器（Controller）：业务逻辑     View 传送指令到 Controller Controller 完成业务逻辑后，要求 Model 改变状态 Model 将新的数据发送到 View，渲染出视图（用户得到反馈）   Vue 是 MVVM MVVM是Model-View-ViewModel的缩写。阮一峰老师也介绍了MVVM，但是实在是过于概括。这里推荐廖雪峰老师的文章：
 MVVM 最早由微软提出来，它借鉴了桌面应用程序的 MVC 思想，在前端页面中，把 Model 用纯 JavaScript 对象表示，View 负责显示，两者做到了最大限度的分离。"><meta itemprop="datePublished" content="2022-03-01T16:15:19+08:00" />
<meta itemprop="dateModified" content="2022-03-01T16:15:19+08:00" />
<meta itemprop="wordCount" content="101">
<meta itemprop="keywords" content="" />
  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Vue 之 MVVM"/>
<meta name="twitter:description" content="Vue 是 MVVM？ v1.0 版本 在vue v1.0版本的官网上有这么一张图：
可以看到在v1.0版本，当时vue把自己定义为一个MVVM模型的框架：
 Vue.js 拥抱数据驱动的视图概念。通俗地讲，它意味着我们在普通 HTML 模板中使用特殊的语法将 DOM “绑定”到底层数据。一旦创建了绑定，DOM 将与数据保持同步。每当修改了数据，DOM 便相应地更新。这样我们应用中的逻辑就几乎都是直接修改数据了，不必与 DOM 更新搅在一起。
 v2.x v3.x 版本 但是在后来的版本，vue的官网上就移除了这张图的介绍，取而代之的是下面这句话：
 虽然没有完全遵循 MVVM 模型，但是 Vue 的设计也受到了它的启发。
 在v2.x、v3.x版本，vue更像是一个MV*模型，因为它确实有些地方没有遵循MVVM模型。其实不必纠结这个*具体是指什么。
先顺便了解一下 MVC 引用阮一峰老师的文章，在前端层面可以很容易的理解什么是MCV：
  模型（Model）：数据保存 视图（View）：用户界面 控制器（Controller）：业务逻辑     View 传送指令到 Controller Controller 完成业务逻辑后，要求 Model 改变状态 Model 将新的数据发送到 View，渲染出视图（用户得到反馈）   Vue 是 MVVM MVVM是Model-View-ViewModel的缩写。阮一峰老师也介绍了MVVM，但是实在是过于概括。这里推荐廖雪峰老师的文章：
 MVVM 最早由微软提出来，它借鉴了桌面应用程序的 MVC 思想，在前端页面中，把 Model 用纯 JavaScript 对象表示，View 负责显示，两者做到了最大限度的分离。"/>

  
  
</head>


  <body class="not-ready" data-menu="false">
    <header class="header">
  
  <p class="logo">
    <a class="site-name" href="https://jinchengjoker.github.io/">金成的博客</a><a class="btn-dark"></a>
  </p>
  

  <script>
    let bodyClx = document.body.classList;
    let btnDark = document.querySelector('.btn-dark');
    let sysDark = window.matchMedia('(prefers-color-scheme: dark)');
    let darkVal = localStorage.getItem('dark');

    let setDark = (isDark) => {
      bodyClx[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark ? 'yes' : 'no');
    };

    setDark(darkVal ? darkVal === 'yes' : sysDark.matches);
    requestAnimationFrame(() => bodyClx.remove('not-ready'));

    btnDark.addEventListener('click', () => setDark(!bodyClx.contains('dark')));
    sysDark.addEventListener('change', (event) => setDark(event.matches));
  </script>

  
  

  
</header>


    <main class="main">

<article class="post-single">
  <header class="post-title">
    <p>
      
      <time>Mar 1, 2022</time>
      
      
    </p>
    <h1>Vue 之 MVVM</h1>
  </header>
  <section class="post-content"><h2 id="vue-是-mvvm">Vue 是 MVVM？</h2>
<h3 id="v10-版本">v1.0 版本</h3>
<p>在<a href="https://v1-cn.vuejs.org/guide/overview.html"><code>vue v1.0</code></a>版本的官网上有这么一张图：</p>
<p><img src="./images/mvvm.png" alt="mvvm"></p>
<p>可以看到在<code>v1.0</code>版本，当时<code>vue</code>把自己定义为一个<code>MVVM</code>模型的框架：</p>
<blockquote>
<p><em>Vue.js 拥抱数据驱动的视图概念。通俗地讲，它意味着我们在普通 HTML 模板中使用特殊的语法将 DOM “绑定”到底层数据。一旦创建了绑定，DOM 将与数据保持同步。每当修改了数据，DOM 便相应地更新。这样我们应用中的逻辑就几乎都是直接修改数据了，不必与 DOM 更新搅在一起。</em></p>
</blockquote>
<h3 id="v2x-v3x-版本">v2.x v3.x 版本</h3>
<p>但是在后来的版本，<code>vue</code>的官网上就移除了这张图的介绍，取而代之的是下面这句话：</p>
<blockquote>
<p><em>虽然没有完全遵循 MVVM 模型，但是 Vue 的设计也受到了它的启发。</em></p>
</blockquote>
<p>在<code>v2.x</code>、<code>v3.x</code>版本，<code>vue</code>更像是一个<code>MV*</code>模型，因为它确实有些地方没有遵循<code>MVVM</code>模型。其实不必纠结这个<code>*</code>具体是指什么。</p>
<h2 id="先顺便了解一下-mvc">先顺便了解一下 MVC</h2>
<p>引用<a href="https://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html">阮一峰老师的文章</a>，在<em>前端层面</em>可以很容易的理解什么是<code>MCV</code>：</p>
<blockquote>
<ul>
<li><em>模型（Model）：数据保存</em></li>
<li><em>视图（View）：用户界面</em></li>
<li><em>控制器（Controller）：业务逻辑</em></li>
</ul>
</blockquote>
<p><img src="./images/mvc.png" alt="mvvm"></p>
<blockquote>
<ol>
<li><em>View 传送指令到 Controller</em></li>
<li><em>Controller 完成业务逻辑后，要求 Model 改变状态</em></li>
<li><em>Model 将新的数据发送到 View，渲染出视图（用户得到反馈）</em></li>
</ol>
</blockquote>
<h2 id="vue-是-mvvm-1">Vue 是 MVVM</h2>
<p><code>MVVM</code>是<code>Model-View-ViewModel</code>的缩写。阮一峰老师也介绍了<code>MVVM</code>，但是实在是过于概括。这里推荐<a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1108898947791072">廖雪峰老师的文章</a>：</p>
<blockquote>
<p><em>MVVM 最早由微软提出来，它借鉴了桌面应用程序的 MVC 思想，在前端页面中，把 Model 用纯 JavaScript 对象表示，View 负责显示，两者做到了最大限度的分离。</em></p>
</blockquote>
<blockquote>
<p><em>把 Model 和 View 关联起来的就是 ViewModel。ViewModel 负责把 Model 的数据同步到 View 显示出来，还负责把 View 的修改同步回 Model。</em></p>
</blockquote>
<p>这说的不就是双向绑定吗？这句话跟<code>vue 1.0</code>版本的介绍完美契合，所以明白了为什么当时<code>vue</code>说自己是一个<code>MVVM</code>模型的框架。</p>
<h2 id="vue-不是-mvvm">Vue 不是 MVVM</h2>
<p>那又为什么说<code>vue</code>不是<code>MVVM</code>模型呢？我又找到了<a href="https://www.zhihu.com/question/327050991">知乎的这个问题</a>的一个答案：</p>
<p><img src="./images/vue$refs.jpg" alt="vue$refs"></p>
<blockquote>
<p><em>ref 属性虽然为父组件操作子组件大开了方便之门，但是它绕开了 ViewModel 来访问 View。</em></p>
</blockquote>
<blockquote>
<p><em>严格的 MVVM 要求 View 不能和 Model 直接通信，而 vue 在组件提供了 $refs 这个属性，可以直接操作 View，违反了这一要求。</em></p>
</blockquote>
<p>所以说<code>vue</code>不是<code>MVVM</code>模型，或者说没有完全遵循<code>MVVM</code>模型。</p>
<h2 id="总结">总结</h2>
<p>说白了，无论是<code>MVC</code>中的<code>C</code>，还是<code>MVVM</code>中的<code>VM</code>，都好像是用来<em>干脏活累活</em>的：</p>
<ul>
<li><code>MVC</code>中的<code>C</code>对应业务逻辑</li>
<li><code>MVVM</code>中的<code>VM</code>对应<code>vue</code>的数据绑定和事件监听</li>
</ul>
<p>可以把<code>VM</code>理解为就是<code>C</code>的一个实例，因为还有<code>MVP</code>，甚至以后可能还有<code>MVA</code>、<code>MVB</code>&hellip;等等，它们多多少少都是借鉴了<code>MVC</code>而演变而来。</p>
<p>所以<code>vue</code>是<code>MVVM</code>也好，不是也罢，这些都不重要，重要的是了解它们背后的思想和原理。</p>
</section>

  
  

  
  
  
  <nav class="post-nav">
     
    <a class="next" href="https://jinchengjoker.github.io/posts/vue/vue_runtime_runtime-only/"><span>Vue 运行时&#43;编译器 vs. 仅运行时</span><span>→</span></a>
    
  </nav>
  

  
  
</article>

</main>

    <footer class="footer">
  <p>&copy; 2022 <a href="https://jinchengjoker.github.io/">金成的博客</a></p>
  <p>Powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo️️</a>️</p>
  <p>
    <a href="https://github.com/nanxiaobei/hugo-paper" rel="noopener" target="_blank">Paper 5.1</a>
  </p>
</footer>

  </body>
</html>
