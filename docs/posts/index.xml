<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 金成的博客</title>
    <link>https://jinchengjoker.github.io/posts/</link>
    <description>Recent content in Posts on 金成的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <lastBuildDate>Wed, 30 Mar 2022 10:29:15 +0800</lastBuildDate><atom:link href="https://jinchengjoker.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Vue2 data 选项存在的问题</title>
      <link>https://jinchengjoker.github.io/posts/vue/vue2_data_problem/</link>
      <pubDate>Wed, 30 Mar 2022 10:29:15 +0800</pubDate>
      
      <guid>https://jinchengjoker.github.io/posts/vue/vue2_data_problem/</guid>
      <description>来自 Vue 的警告 new Vue({ data: {}, template: ` &amp;lt;div&amp;gt;{{n}}&amp;lt;/div&amp;gt; ` }).$mount(&amp;#34;#app&amp;#34;); 上面的例子中，在template选项里使用了n，但在data选项中并没有初始化n，这时vue会在控制台发出警告：
 [Vue warn]: Property or method &amp;quot;n&amp;quot; is not defined on the instance but referenced during render. Make sure that this property is reactive, either in the data option, or for class-based components, by initializing the property.
 这是因为vue2是使用的Object.defineProperty来实现数据响应式：
Object.defineProperty(data, &amp;#39;xxx&amp;#39;, { ... }) vue会遍历data选项内所有的属性并进行代理，前提是要有明确的key，即需要事先声明好key才能进行遍历。在模板中使用了没有事先声明的属性，vue无法对其进行代理并做出响应。
所以改为以下写法可以消除警告：
new Vue({ data: { n: null }, template: ` &amp;lt;div&amp;gt;{{n}}&amp;lt;/div&amp;gt; ` }).</description>
    </item>
    
    <item>
      <title>Vue 数据响应式原理</title>
      <link>https://jinchengjoker.github.io/posts/vue/vue_data_reactivity/</link>
      <pubDate>Sun, 06 Mar 2022 14:39:28 +0800</pubDate>
      
      <guid>https://jinchengjoker.github.io/posts/vue/vue_data_reactivity/</guid>
      <description>断断续续已经用了很长时间的vue了，从之前的vue2到现在的vue3。说起它的数据响应式原理，一直都是比较模糊的，只是大概知道是通过Object.defineProperty()和代理来实现的，具体也没有去深入的了解。
最近看了一些文章和视频，所以在这里进行一些总结。
先了解一下 ES6 的 getter/setter 一个简单的例子了解getter/setter的基本用法：
const obj = { lastName: &amp;#34;高&amp;#34;, firstName: &amp;#34;圆圆&amp;#34;, get name() { return this.lastName + this.firstName }, set name(value){ this.lastName = value[0] this.firstName = value.substring(1) }, } console.log(obj.name) // 高圆圆  obj.name = &amp;#39;刘诗诗&amp;#39; console.log(`姓：${obj.lastName}`) // 姓：刘 console.log(`名：${obj.firstName}`) // 名：诗诗 需求一 上面的例子在声明obj的时候就已经定义了name的getter/setter，那如何在一个已有的对象上添加一个新的getter/setter？
再了解一下 ES6 的 Object.defineProperty 用ES6的新语法Object.defineProperty可以实现上述需求。
例如给obj对象添加一个age的getter/setter：
let _age = 0 Object.defineProperty(obj, &amp;#39;age&amp;#39;, { get() { return _age }, set(value) { _age = value } }) 这里需要一个_age变量作为临时存储，为了方便可以把这个临时的_age放到obj里：</description>
    </item>
    
    <item>
      <title>到底什么是前端架构？</title>
      <link>https://jinchengjoker.github.io/posts/misc/fe_arch/</link>
      <pubDate>Wed, 02 Mar 2022 20:30:50 +0800</pubDate>
      
      <guid>https://jinchengjoker.github.io/posts/misc/fe_arch/</guid>
      <description>文件夹划分师 </description>
    </item>
    
    <item>
      <title>Vue 之 MVVM</title>
      <link>https://jinchengjoker.github.io/posts/vue/vue_mvvm/</link>
      <pubDate>Tue, 01 Mar 2022 16:15:19 +0800</pubDate>
      
      <guid>https://jinchengjoker.github.io/posts/vue/vue_mvvm/</guid>
      <description>Vue 是 MVVM？ v1.0 版本 在vue v1.0版本的官网上有这么一张图：
可以看到在v1.0版本，当时vue把自己定义为一个MVVM模型的框架：
 Vue.js 拥抱数据驱动的视图概念。通俗地讲，它意味着我们在普通 HTML 模板中使用特殊的语法将 DOM “绑定”到底层数据。一旦创建了绑定，DOM 将与数据保持同步。每当修改了数据，DOM 便相应地更新。这样我们应用中的逻辑就几乎都是直接修改数据了，不必与 DOM 更新搅在一起。
 v2.x v3.x 版本 但是在后来的版本，vue的官网上就移除了这张图的介绍，取而代之的是下面这句话：
 虽然没有完全遵循 MVVM 模型，但是 Vue 的设计也受到了它的启发。
 在v2.x、v3.x版本，vue更像是一个MV*模型，因为它确实有些地方没有遵循MVVM模型。其实不必纠结这个*具体是指什么。
先顺便了解一下 MVC 引用阮一峰老师的文章，在前端层面可以很容易的理解什么是MCV：
  模型（Model）：数据保存 视图（View）：用户界面 控制器（Controller）：业务逻辑     View 传送指令到 Controller Controller 完成业务逻辑后，要求 Model 改变状态 Model 将新的数据发送到 View，渲染出视图（用户得到反馈）   Vue 是 MVVM MVVM是Model-View-ViewModel的缩写。阮一峰老师也介绍了MVVM，但是实在是过于概括。这里推荐廖雪峰老师的文章：
 MVVM 最早由微软提出来，它借鉴了桌面应用程序的 MVC 思想，在前端页面中，把 Model 用纯 JavaScript 对象表示，View 负责显示，两者做到了最大限度的分离。</description>
    </item>
    
    <item>
      <title>Vue 运行时&#43;编译器 vs. 仅运行时</title>
      <link>https://jinchengjoker.github.io/posts/vue/vue_runtime_runtime-only/</link>
      <pubDate>Tue, 22 Feb 2022 14:50:43 +0800</pubDate>
      
      <guid>https://jinchengjoker.github.io/posts/vue/vue_runtime_runtime-only/</guid>
      <description>在vue npm包的 dist/ 目录有很多不同的Vue.js构建版本。
 vue.global.js - 包含编译器和运行时的完整版（约 520KB） vue.global.prod.js - 包含编译器和运行时的压缩后完整版（约 105KB） vue.runtime.global.js - 只包含运行时（约 356KB） vue.runtime.global.prod.js - 只包含运行时的压缩版（约 68KB）  如果要在客户端上编译模板（即：将字符串传递给template选项，或者使用元素的DOM内HTML作为模板挂载到元素），则需要编译器，因此需要完整的构建版本：
&amp;lt;!-- index.html --&amp;gt; &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;h1&amp;gt;{{hi}}&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; // main.js // 以 vue3 写法为例  // 需要编译器 // 会直接替换 app 元素的内容 Vue.createApp({ template: &amp;#39;&amp;lt;div&amp;gt;{{ hi }}&amp;lt;/div&amp;gt;&amp;#39;, data() { return { hi: &amp;#34;hi&amp;#34; }; } }).mount(&amp;#39;#app&amp;#39;) // 需要编译器 // 相当于使用 app 元素的 DOM 内 HTML 作为模板 Vue.createApp({ data() { return { hi: &amp;#34;hi&amp;#34; }; } }).</description>
    </item>
    
    <item>
      <title>在 NPM 上发布一个命令行工具包</title>
      <link>https://jinchengjoker.github.io/posts/misc/make_npm_package/</link>
      <pubDate>Mon, 08 Jun 2020 00:00:00 +0800</pubDate>
      
      <guid>https://jinchengjoker.github.io/posts/misc/make_npm_package/</guid>
      <description>以自己写的一个命令行工具 demo为例。
修改 package.json { &amp;#34;name&amp;#34;: &amp;#34;zy-todo&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;0.0.1&amp;#34;, &amp;#34;main&amp;#34;: &amp;#34;index.js&amp;#34;, &amp;#34;bin&amp;#34;: { &amp;#34;zydo&amp;#34;: &amp;#34;cli.js&amp;#34; }, &amp;#34;files&amp;#34;: [ &amp;#34;*.js&amp;#34; ], &amp;#34;license&amp;#34;: &amp;#34;MIT&amp;#34;, &amp;#34;dependencies&amp;#34;: { &amp;#34;commander&amp;#34;: &amp;#34;^5.1.0&amp;#34;, &amp;#34;inquirer&amp;#34;: &amp;#34;^7.1.0&amp;#34; } }  name：必须是唯一的，不能和其他已发布的包重名。 version：发布的包的版本号。 main：整个包的主要逻辑文件，一般是 index.js。 bin：如果这个包是一个命令行工具，那么最终生成的命令是什么，以及命令对应执行的文件是什么。 files：告诉 NPM 哪些文件是有用的。  shebang shebang 写在某个文件的头部，用来告诉命令行用什么程序来执行这个文件。
例如我这个包是用 node 执行 cli.js 文件，那么就在 cli.js 文件头部写入：
#!/usr/bin/env node 可行性权限 在 Linux 和 Mac OS 下还需要给文件加上可执行权限：
chmod +x cli.js NPM 发布 发布包需要一个 NPM 账号。
必须使用 npm 的官方源进行发布，淘宝源不支持发布。</description>
    </item>
    
    <item>
      <title>Promise、微任务、宏任务</title>
      <link>https://jinchengjoker.github.io/posts/js/promise/</link>
      <pubDate>Mon, 24 Feb 2020 00:00:00 +0800</pubDate>
      
      <guid>https://jinchengjoker.github.io/posts/js/promise/</guid>
      <description>基本用法 const roll = () =&amp;gt; { return new Promise((resolve, reject) =&amp;gt; { setTimeout(() =&amp;gt; { resolve(Math.floor(Math.random() * 6) + 1) }, 1000) }) } roll() .then( (result) =&amp;gt; { console.log(result) }, (reason) =&amp;gt; { console.log(&amp;#39;reason: &amp;#39; + reason) } ) 多次处理一个结果 上一个 then 的返回值会传递给下一个 then，可以继续处理。
roll() .then((r1) =&amp;gt; r1) .then((r2) =&amp;gt; console.log(r2 * 10)) 错误处理 如果上一个 then 抛出了错误，那么下一个 then 就需要继续处理错误。如果没有抛出错误，就不需要继续处理错误。
roll() .then(null, (err1) =&amp;gt; { throw new Error(err1) }) .</description>
    </item>
    
    <item>
      <title>用 JS 理解递归</title>
      <link>https://jinchengjoker.github.io/posts/misc/recursion/</link>
      <pubDate>Mon, 06 Jan 2020 00:00:00 +0800</pubDate>
      
      <guid>https://jinchengjoker.github.io/posts/misc/recursion/</guid>
      <description>简单阶乘的例子 const j = (n) =&amp;gt; n === 1 ? 1 : n * j(n-1) 上面的函数，可以计算出从 1 到任意正整数 n 的阶乘。
这就是最简单的递归，一个函数的内部通过某种条件进行判断，并且调用了自己。
斐波那契数列的例子 斐波那契数列：数列的第一项和第二项都为 1，从第三项开始每一项都为前两项之和。
为了编程的习惯，假设第零项为 0，也能满足斐波那契数列的要求。
用递归求斐波那契数列第 n 项的值：
const j = (n) =&amp;gt; n === 0 ? 0 : n === 1 ? 1 : j(n-1) + j(n-2) 调用栈 上面的例子，由于使用了递归，所以会在调用栈中进行压栈，主要用来记忆每次计算之后“回到哪里”。
当调用栈压栈次数过多，计算就会非常的缓慢，甚至爆栈。
比如计算斐波那契数列第 40 项，可能需要一秒；计算第 50 项就需要几十秒。
所以需要优化的就是如何降低压栈/计算次数。
用尾递归（迭代）优化 尾递归就是在函数的尾巴进行迭代。
因为不需要“回头”了，所以使用尾递归可以大大减少压栈和重复计算次数。
const j = (n) =&amp;gt; f(2, n, 1, 0) const f = (start, end, prev1, prev2) =&amp;gt; end === 0 ?</description>
    </item>
    
    <item>
      <title>JS 中的函数</title>
      <link>https://jinchengjoker.github.io/posts/js/function_in_js/</link>
      <pubDate>Thu, 26 Dec 2019 00:00:00 +0800</pubDate>
      
      <guid>https://jinchengjoker.github.io/posts/js/function_in_js/</guid>
      <description>函数的返回值由什么确定？ 一个函数的返回值，由两个因素决定：
 定义时的环境 env 调用时输入的参数 params  举例：
let x = &amp;#39;x&amp;#39; let a = &amp;#39;1&amp;#39; function f1(x){ return x + a } { let a = &amp;#39;2&amp;#39; f1(&amp;#39;y&amp;#39;) // 值为 &amp;#39;y1&amp;#39; } 在函数 f1 中：
 x 是参数，所以 x 的值在调用 f1 的时候确定。 a 不是参数，所以 a 的值在 f1 定义时，由它所处的环境确定。  let x = &amp;#39;x&amp;#39; let a = &amp;#39;1&amp;#39; function f1(x){ return x + a } a = &amp;#39;3&amp;#39; { let a = &amp;#39;2&amp;#39; f1(&amp;#39;y&amp;#39;) // 值为 &amp;#39;y3&amp;#39; } 另一个例子：</description>
    </item>
    
    <item>
      <title>用 JS 理解函数柯里化</title>
      <link>https://jinchengjoker.github.io/posts/misc/currying/</link>
      <pubDate>Thu, 14 Nov 2019 00:00:00 +0800</pubDate>
      
      <guid>https://jinchengjoker.github.io/posts/misc/currying/</guid>
      <description>一句话解释函数柯里化：让所有函数只接受一个参数。
单一参数 例如，未来的 JS 可能会支持的 pipe 操作：
function doubleSay (str) { return str + &amp;#34;, &amp;#34; + str } function capitalize (str) { return str[0].toUpperCase() + str.substring(1) } function exclaim (str) { return str + &amp;#39;!&amp;#39; } let result = &amp;#34;hello&amp;#34; |&amp;gt; doubleSay |&amp;gt; capitalize |&amp;gt; exclaim result // &amp;#34;Hello, hello!&amp;#34; 或者使用 Ramda.js：
const say = Ramda.compose(doubleSay, capitalize, exclaim) say(&amp;#39;hello&amp;#39;) // &amp;#39;Hello, hello!&amp;#39; 如何让单参数函数支持两个参数 可以用对象：
const add = ({a, b}) =&amp;gt; a + b add({ a: 1, b: 2 }) 或者用箭头函数和闭包来实现：</description>
    </item>
    
    <item>
      <title>JS 实现深拷贝</title>
      <link>https://jinchengjoker.github.io/posts/js/deep_clone/</link>
      <pubDate>Fri, 20 Sep 2019 00:00:00 +0800</pubDate>
      
      <guid>https://jinchengjoker.github.io/posts/js/deep_clone/</guid>
      <description>JSON 序列化和反序列化 对于一般（狭义）的对象，最简单快速的方法就是使用 JSON 的序列化和反序列化：
const o1 = { name: &amp;#39;xxx&amp;#39;, age: 18, child: { name: &amp;#39;zzz&amp;#39; } } const o2 = JSON.parse(JSON.stringify(o1)) o1 === o2 // false o1.name === o2.name // true o1.child === o2.child // false o1.child.name === o2.child.name // true 缺点：仅支持 JSON 所支持的数据类型和结构。
例如：
 不支持函数，会被直接忽略 不支持 undefined，会被直接忽略 不支持循环引用，例如 xxx.self = xxx，会报错  对于更复杂的对象，就无法使用上面的办法，需要使用递归来进行深拷贝。
搭建测试环境 安装 mocha、chai 和 sinon-chai：
yarn init -yyarn add mocha chai sinon-chai --devpackage.</description>
    </item>
    
    <item>
      <title>用 TS 实现 EventHub（发布/订阅模式）</title>
      <link>https://jinchengjoker.github.io/posts/misc/eventhub/</link>
      <pubDate>Wed, 11 Sep 2019 00:00:00 +0800</pubDate>
      
      <guid>https://jinchengjoker.github.io/posts/misc/eventhub/</guid>
      <description>确定 API  EventHub#on EventHub#emit EventHub#off  测试环境搭建 TDD：测试驱动开发
安装 ts-node：
yarn global add ts-node初始化一个 EventHub 类：
// index.ts  class EventHub {} export default EventHub 编写测试用例：
// test/index.ts  import EventHub from &amp;#39;../index&amp;#39; // 测试 eventhub 是否正确生成 const testEventHub = (message) =&amp;gt; { const eventhub = new EventHub() console.assert(eventhub instanceof Object === true, &amp;#39;eventhub 应该是一个 object&amp;#39;) console.log(message) } testEventHub(&amp;#39;测试 eventhub 是否正确生成&amp;#39;) 用 ts-node 运行测试：
ts-node test/index.ts初步实现 on 和 emit 添加测试用例：</description>
    </item>
    
    <item>
      <title>JS 高阶函数</title>
      <link>https://jinchengjoker.github.io/posts/js/higher_function/</link>
      <pubDate>Tue, 03 Sep 2019 00:00:00 +0800</pubDate>
      
      <guid>https://jinchengjoker.github.io/posts/js/higher_function/</guid>
      <description>一句话解释高阶函数：把函数作为参数或者返回值的函数。
JS 中部分内置的高阶函数  Function.prototype.bind Function.prototype.apply Function.prototype.call Array.prototype.sort Array.prototype.map Array.prototype.filter Array.prototype.reduce  bind/apply/call.call() 是什么意思 例如，bind的一般用法：
var f1 = function() { console.log(this) console.log(arguments) } var newF1 = f1.bind({ name: &amp;#39;john&amp;#39; }, 1, 2) newF1() // {name: &amp;#39;john&amp;#39;} // [1, 2] 推理：
 已知obj.method(a, b, c)等价于obj.method.call(obj, a, b, c)。 假设obj = f1，method = bind。 那么f1.bind(a, b, c)等价于f1.bind.call(f1, a, b, c)。 假设a = { name: &#39;john&#39; }，b = 1，c = 2。 那么f1.bind({ name: &#39;john&#39; }, 1, 2)这就是一般的用法，它等价于f1.</description>
    </item>
    
    <item>
      <title>AJAX</title>
      <link>https://jinchengjoker.github.io/posts/bom/ajax/</link>
      <pubDate>Thu, 05 Jul 2018 01:46:17 +0800</pubDate>
      
      <guid>https://jinchengjoker.github.io/posts/bom/ajax/</guid>
      <description>全称 Async Javascript and XML。
使用 XMLHttpRequest 浏览器提供了一个 XMLHttpRequest 方法，可以通过 new XMLHttpRequest() 创建一个可以发起 HTTP 请求的对象。
let request = new XMLHttpRequest() // 创建 HTTP 请求对象  request.open(&amp;#39;POST&amp;#39;, &amp;#39;/xxx&amp;#39;) // 初始化请求，默认为异步 request.setRequestHeader(&amp;#39;Content-Type&amp;#39;, &amp;#39;application/x-www-form-urlencoded&amp;#39;) request.send(&amp;#39;这是要发送的数据&amp;#39;) // 发送请求 request.onreadystatechange = () =&amp;gt; { if(request.readyState === 4) { // 请求和响应已完毕  if(request.status &amp;gt;= 200 &amp;amp;&amp;amp; request.status &amp;lt; 300) { console.log(&amp;#39;请求成功&amp;#39;) console.log(request.getResponseHeader(&amp;#39;Content-Type&amp;#39;)) console.log(JSON.parse(request.responseText)) } else if(request.status &amp;gt;= 400) { console.log(&amp;#39;请求失败&amp;#39;) } } } 在 request 实例中：</description>
    </item>
    
    <item>
      <title>CORS 跨域资源共享</title>
      <link>https://jinchengjoker.github.io/posts/bom/cors/</link>
      <pubDate>Wed, 04 Jul 2018 18:46:17 +0800</pubDate>
      
      <guid>https://jinchengjoker.github.io/posts/bom/cors/</guid>
      <description>同源策略 因为安全问题，浏览器规定：只有在 协议、域名、端口号 一模一样的情况下，才可以通过 AJAX 发送请求。
那为什么 form 没有跨域问题？
因为用 form 发请求会刷新或离开当前页面，且用 form 提交到另一个域名之后，原页面的脚本无法获取新页面中的内容。
所以浏览器认为这是安全的。
实际上用 &amp;lt;a&amp;gt;、&amp;lt;img&amp;gt;、&amp;lt;link&amp;gt;、&amp;lt;script&amp;gt; 这些标签都可以发起请求，且都没有同源策略的限制。
而 AJAX 是可以直接读取响应内容的，因此浏览器不允许这样做。
CORS 全称 Cross-Origin Resource Sharing
虽然浏览器制定了同源策源，但是我们可以通过 CORS 来突破它，即跨域。
在服务器的响应中添加：
response.setHeader(&amp;#39;Access-Control-Allow-Origin&amp;#39;, &amp;#39;http://xxx&amp;#39;) // 或者 response.setHeader(&amp;#39;Access-Control-Allow-Origin&amp;#39;, &amp;#39;*&amp;#39;) </description>
    </item>
    
    <item>
      <title>JSONP</title>
      <link>https://jinchengjoker.github.io/posts/bom/jsonp/</link>
      <pubDate>Tue, 03 Jul 2018 21:00:55 +0800</pubDate>
      
      <guid>https://jinchengjoker.github.io/posts/bom/jsonp/</guid>
      <description>JSONP 是服务器与客户端跨源通信的常用方法。
它的基本思想是，通过动态创建 &amp;lt;script&amp;gt; 元素向服务器发起请求，这种做法不受同源政策限制。服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。
通过一个简单的例子来理解 JSONP 到底是什么。
Demo 地址
简易服务器 用 node.js 搭一个简易的服务器 server.js：
var http = require(&amp;#39;http&amp;#39;) var url = require(&amp;#39;url&amp;#39;) var fs = require(&amp;#39;fs&amp;#39;) var port = process.argv[2] // 判断是否传入端口号参数 if(!port) { console.log(&amp;#39;请指定端口号！\n例如：node server.js 8888&amp;#39;) process.exit(1) } // 创建服务器 var server = http.createServer( function(request, response) { var temp = url.parse(request.url, true) var path = temp.pathname var query = temp.query console.log(&amp;#39;HTTP 请求路径为：\n&amp;#39; + path) // 判断 HTTP 请求路径  if(path === &amp;#39;/&amp;#39;) { var data = fs.</description>
    </item>
    
    <item>
      <title>DOM 事件标准与模型</title>
      <link>https://jinchengjoker.github.io/posts/dom/dom_events/</link>
      <pubDate>Tue, 26 Jun 2018 01:22:28 +0800</pubDate>
      
      <guid>https://jinchengjoker.github.io/posts/dom/dom_events/</guid>
      <description>DOM Level 0 它不是一个标准，只是对各个浏览器支持的 DOM 事件的统称。
btn.onclick = function() { console.log(&amp;#39;hi&amp;#39;) } btn.onmouseenter = function() { console.log(&amp;#39;mouseenter&amp;#39;) } btn.onmouseleave = function() { console.log(&amp;#39;mouseleave&amp;#39;) } DOM Level 1 把各个浏览器支持的 DOM 事件进行汇总，形成规范标准。
DOM Level 2 现在主要的规范标准。
添加了更多 DOM 事件，以及制定了事件流、事件捕获、事件冒泡和事件取消等更多标准。
btn.addEventListener(&amp;#39;click&amp;#39;, function() { console.log(&amp;#39;hi&amp;#39;) }) btn.addEventListener(&amp;#39;mouseenter&amp;#39;, function() { console.log(&amp;#39;mouseenter&amp;#39;) }) btn.addEventListener(&amp;#39;mouseleave&amp;#39;, function() { console.log(&amp;#39;mouseleave&amp;#39;) }) 和 DOM Level 1 的区别 它们区别在于，DOM Level 1 只是一个属性，属性是唯一的，也就是说一个元素只可能有一个 onclick 属性，这意味着不能多次绑定同一事件。
btn.onclick = function() { // 将会被覆盖  console.</description>
    </item>
    
    <item>
      <title>排序算法</title>
      <link>https://jinchengjoker.github.io/posts/algorithm/sort/</link>
      <pubDate>Tue, 22 May 2018 23:30:28 +0800</pubDate>
      
      <guid>https://jinchengjoker.github.io/posts/algorithm/sort/</guid>
      <description>冒泡排序 基本思路  依次两两对比，大小互换，越大的数越往后排，每一轮可以确定一个数。 把剩下的数重复该操作。  算法实现 function bubbleSort(arr) { // 所需轮数 arr.length - 1  for(let l = 0; l &amp;lt; arr.length - 1; l++) { // 每一轮找出一个最大值  for(let i = 0; i &amp;lt; arr.length - 1 - l; i++) { if(arr[i] &amp;gt; arr[i+1]) { let temp = arr[i] arr[i] = arr[i+1] arr[i+1] = temp } } } return arr } 选择排序 基本思路  每一轮找出其中的一个最大数，排在其最后一位，每一轮可以确定一个数。 把剩下的数重复该操作。  算法实现 function selectSort(arr) { let length = arr.</description>
    </item>
    
    <item>
      <title>HTTP 基础知识</title>
      <link>https://jinchengjoker.github.io/posts/http/http_basic/</link>
      <pubDate>Sun, 13 May 2018 17:09:20 +0800</pubDate>
      
      <guid>https://jinchengjoker.github.io/posts/http/http_basic/</guid>
      <description>HTTP HyperText Transfer Protocol 超文本传输协议，用于控制客户端与服务器之间如何进行沟通传输。
URL Uniform Resource Locator 统一资源定位符，也被俗称为网址。
例如：https://www.baidu.com/s?wd=hello&amp;amp;rsv_spt=1#5 就是一个 URL。
其中包括：协议、域名、路径、查询参数、锚点和端口号。
 域名  .com 为顶级域名，baidu 为二级域名，www 为三级域名。
 路径  并不对应任何文件。
 端口号  例如：21 端口用于 FTP 服务，443 端口用于 HTTPS 服务，1080 端口用于代理服务，3306 端口用于 MySQL 服务，80 端口用于 HTTP 服务。
DNS Domain Name System 域名系统，用于将域名解析为对应的 IP。
可以使用 nslookup 工具查询对应的 IP。
nslookup www.baidu.comHosts 更改 hosts 文件可以指定任意域名的 IP。
客户端与服务器的基本交互 客户端与服务器之间使用 HTTP。
 客户端浏览器输入 URL 通过 DNS 解析，获取 IP 地址 请求该 IP 地址 80 端口 进行 TCP 的三次握手 服务器响应 浏览器接受下载数据  发起请求 基本格式 第1部分：动词 路径 协议/版本号第2部分：Key: value.</description>
    </item>
    
    <item>
      <title>JS 中的 this 和 arguments</title>
      <link>https://jinchengjoker.github.io/posts/js/this_and_arguments/</link>
      <pubDate>Thu, 26 Apr 2018 22:38:38 +0800</pubDate>
      
      <guid>https://jinchengjoker.github.io/posts/js/this_and_arguments/</guid>
      <description>this 到底指的是什么 首先我们知道函数的两种调用方式：
function sum(a, b) { return a + b } // 第一种方式 sum(1, 2) // 3  // 第二种方式 sum.call(undefined, 1, 2) // 3 如果函数以 .call() 的方式调用，那么其实 this 通常指的就是第一个参数。暂时不讨论以 () 的方式调用。
但是需要注意的是：
 当第一个参数为 undefined、null 或空时，在非严格模式下，this 会自动指向全局 window 对象。  // 非严格模式 function fn() { console.log(this) } fn.call() // 全局 window 对象 fn.call(undefined) // 全局 window 对象 fn.call(null) // 全局 window 对象  // 使用严格模式 function fn() { &amp;#39;use strict&amp;#39; console.</description>
    </item>
    
    <item>
      <title>JS 中的数组</title>
      <link>https://jinchengjoker.github.io/posts/js/array_in_js/</link>
      <pubDate>Tue, 24 Apr 2018 21:06:06 +0800</pubDate>
      
      <guid>https://jinchengjoker.github.io/posts/js/array_in_js/</guid>
      <description>JS 中的数组到底是什么？ JS 中的数组其实就是一种特殊的对象。
typeof [1, 2, 3] // &amp;#34;object&amp;#34; 它和狭义上的对象的本质区别就是，键名是按次序排列的一组整数（0，1，2 &amp;hellip;），且继承了 Array.prototype 属性，可以调用一系列 Array 提供的方法。
伪数组 如果一个对象的所有键名是按次序排列的一组整数（0，1，2 &amp;hellip;），含有 length 属性且没有继承 Array.prototype 属性，不具备数组特有的方法，那么这个对象就是伪数组。语法上称为“类似数组的对象”。
例如函数的 arguments 对象就是一个伪数组：
以及大多数 DOM 返回的元素集也是伪数组。
数组的常用方法 静态方法  Array.isArray()  该方法返回一个布尔值，表示传入的参数是否为数组。可以弥补 typeof 运算符的不足。
var arr = [1, 2, 3] typeof arr // &amp;#34;object&amp;#34; Array.isArray(arr) // true 实例方法  Array.prototype.sort()  使用该方法原数组将被改变。
sort() 方法对数组成员进行排序，默认是按照字典顺序排序(不是大小顺序)。
如果需要按照自定义顺序排序，需要传入一个函数参数，参数函数可以接受两个参数，表示进行比较的两个数组元素。如果该函数的返回值大于0，表示第一个元素排在第二个元素后面；其他情况下，都是第一个元素排在第二个元素前面。
[&amp;#39;d&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;a&amp;#39;].sort() // [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;] [4, 3, 2, 1].</description>
    </item>
    
    <item>
      <title>JS 中的原型和原型链</title>
      <link>https://jinchengjoker.github.io/posts/js/prototype/</link>
      <pubDate>Fri, 20 Apr 2018 09:00:22 +0800</pubDate>
      
      <guid>https://jinchengjoker.github.io/posts/js/prototype/</guid>
      <description>公用属性 用全局函数包装下面几个对象：
var n = new Number(1) var s = new String(&amp;#39;hello&amp;#39;) var b = new Boolean(true) var o = new Object() 可以发现，他们都可以调用例如 toString() 和 valueOf() 等一些方法。
那如果每一个对象都自己去存有这些属性，一个明显的问题就是会造成资源的浪费。
JS 的解决办法就是，把这些函数统一放在一个对象里（暂且叫做公用属性组成的对象）。当声明一个新的对象时，就给这个新的对象添加一个隐藏的属性 __proto__，在这个属性中去存公用属性对象的 Heap 地址，这样就完成了对公用属性的引用。
Object 对象的公用属性 举个例子：
var o1 = {} o1.name = &amp;#39;JinCheng&amp;#39; o1.age = 20 console.log(o1) 就会发现额外隐藏的 __proto__ 属性。
当调用 o1.toString() 时：
 首先会看 o1 是不是对象，如果不是，就临时包装成对象。 再看 o1 自身有没有 toString 这个属性可供调用。 如果没有这个属性，就会自动去调用 __proto__ 对象里的属性方法。  简单的验证：
// 再声明一个对象 o2 var o2 = { name: &amp;#39;JinCheng&amp;#39;, age: 20 } o1 === o2 // false 因为 Heap 地址不同 o1.</description>
    </item>
    
    <item>
      <title>JS 中的对象</title>
      <link>https://jinchengjoker.github.io/posts/js/object_in_js/</link>
      <pubDate>Thu, 19 Apr 2018 21:34:49 +0800</pubDate>
      
      <guid>https://jinchengjoker.github.io/posts/js/object_in_js/</guid>
      <description>ECMAScript 规定全局对象叫做 global，但是浏览器把 window 作为全局对象（浏览器先存在的）。
window 有很多属性，这些属性就是全局变量，可供调用。大致分为两种：
 ECMAScript 规定的 Number、String、Boolean、Object &amp;hellip; 浏览器自己添加的 alert、prompt、comfirm、console &amp;hellip;  Number 对象 Number 对象是数值对应的包装对象。
Number() 可以作为工具函数使用，也可以作为构造函数使用（即可以使用new命令）：
 Number(&#39;1&#39;) 尝试把任意值变为数值 var n = new Number(1) 把数值 1 包装成一个对象  那么为什么要把 1 包装成一个对象？
var n1 = 1 var n2 = new Number(1) // 这两个变量有什么区别？ 区别就是内存不同。
打印出 n1 和 n2 可以发现，n1 的值是一个基本类型，直接存在 Stack 中；而 n2 的值则是一个对象，把这个对象的 Heap 地址存在 Stack 中，对象里提供了一些例如 valueOf()、toString() 等可以被调用的属性和方法。
n2.valueOf() // 得到初始值 1 n2.toString() // 转换为字符串 &amp;#39;1&amp;#39; 但奇怪的是，n1 是基本类型，它也可以调用这些方法：</description>
    </item>
    
    <item>
      <title>JS 垃圾回收和内存泄漏</title>
      <link>https://jinchengjoker.github.io/posts/js/garbage_collection_and_memory_leak/</link>
      <pubDate>Wed, 18 Apr 2018 21:23:47 +0800</pubDate>
      
      <guid>https://jinchengjoker.github.io/posts/js/garbage_collection_and_memory_leak/</guid>
      <description>垃圾回收 简单来说，如果一个对象没有被引用，那么它就是垃圾，内存将会被回收。
var a = { name: &amp;#39;a&amp;#39; } var b = { name: &amp;#39;b&amp;#39; } b = a 因为 b 在 Stack 中存的 Heap 地址被 a 覆盖了，所以导致 { name: &#39;b&#39; } 没有被引用，那么它就是垃圾，内存将会被回收。
var fn = function() { console.log(&amp;#39;hello&amp;#39;) } document.body.onclick = fn fn = null // 对象 function() { console.log(&amp;#39;hello&amp;#39;) } 会不会被垃圾回收？ 前两句表示 fn 和 document.body.onclick 在 Stack 中存的是同一个 Heap 地址。
fn = null 表示 fn 在 Stack 中存的 Heap 地址被 null 覆盖了。</description>
    </item>
    
    <item>
      <title>JS 栈内存和堆内存</title>
      <link>https://jinchengjoker.github.io/posts/js/stack_and_heap/</link>
      <pubDate>Tue, 17 Apr 2018 14:34:42 +0800</pubDate>
      
      <guid>https://jinchengjoker.github.io/posts/js/stack_and_heap/</guid>
      <description>简单来说，JS 引擎将内存分为代码区和数据区，而数据区分为 Stack（栈内存）和 Heap（堆内存）。
基本类型的数据直接存入 Stack 里，复杂类型的数据是把 Heap 地址存入 Stack 里，这个地址就是对数据的引用。
记录一下几个关于内存的问题：
   var a = 1 var b = a b = 2 // a = ? 不废话。。。a 的值肯定为 1。
  var a = { name: &amp;#39;a&amp;#39; } var b = a b = { name: &amp;#39;b&amp;#39; } // a.name = ? 因为 a 的值为一个对象（复杂类型），所以 a 其实是把这个对象的 Heap 地址存在 Stack 里。
var b = a 是复制了这个 Heap 地址给 b。</description>
    </item>
    
    <item>
      <title>JS 深浅拷贝</title>
      <link>https://jinchengjoker.github.io/posts/js/shallow_and_deep_clone/</link>
      <pubDate>Tue, 12 Dec 2017 14:43:06 +0800</pubDate>
      
      <guid>https://jinchengjoker.github.io/posts/js/shallow_and_deep_clone/</guid>
      <description>最近在项目中遇到了一个关于数组拷贝的问题。
在 JavaScript 中，一般的简单值（Number/String/Boolean）是通过直接复制来进行赋值的：
var a = 1 var b = a b = 2 console.log(a) // 1 console.log(b) // 2 但是数组和对象如果用以上的方法简单赋值，某些情况下就会出现问题：
var arr1 = [1, 2, 3] var arr2 = arr1 arr1.shift() console.log(arr1) // [2, 3] console.log(arr2) // [2, 3] 上面的示例中，我只删除了 arr1 的第一个元素，但是打印出来会发现 arr1 和 arr2 的值都被改变了。 因为这只是数组的浅拷贝，var arr2 = arr1 只是将 arr1 的内存地址复制给 arr2，两个数组其实指向同一个内存区域。
对象同理：
var obj1 = { name: &amp;#39;luwei&amp;#39;, age: 23 } var obj2 = obj1 obj2.</description>
    </item>
    
    <item>
      <title>开博大吉</title>
      <link>https://jinchengjoker.github.io/posts/%E5%BC%80%E5%8D%9A%E5%A4%A7%E5%90%89/</link>
      <pubDate>Thu, 01 Jun 2017 18:21:16 +0800</pubDate>
      
      <guid>https://jinchengjoker.github.io/posts/%E5%BC%80%E5%8D%9A%E5%A4%A7%E5%90%89/</guid>
      <description>你他娘还真是个人才！ </description>
    </item>
    
  </channel>
</rss>
